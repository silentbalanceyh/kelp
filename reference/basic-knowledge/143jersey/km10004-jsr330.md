# KM10004 - JSR330 Details

Java依赖注入标准（JSR-330，Dependency Injection for Java）——该规范面向以来注入使用者，而对注入器实现、配置病没做详细要求。目前Spring、Guice已经开始兼容该规范，JSR-299（Contexts and Dependency Injection for Java EE platform）在依赖注入上也使用该规范。JSR-330规范并没按JSR惯例发布规范文档，只发布了规范API源代码。

## 1.javax.inject

包javax.inject制定了获取对象的一种方法，该方法和构造器、工厂、服务定位器（如JNDI）这些传统方法相比可以获得更好的可重用性、可测试性和可维护性——就是依赖注入。

在我们的程序中，很多类型依赖于其他类型，如Stopwatch可能依赖一个TimeSource，一些类型被另外一个类型依赖，我们把这些类型叫做**依赖（物）**。在运行时查找一个依赖实例的过程叫做**解析依赖**，如果找不到依赖的实现则称该依赖为**不能满足的**，并导致应用运行失败。

如果不使用依赖注入，对象的依赖解析有几种方式，最常见的就是通过编写直接调用构造函数的代码：

```java
class Stopwatch {
  final TimeSource timeSource;
  Stopwatch () {
    timeSource = new AtomicClock(...);
  }
  void start() { ... }
  long stop() { ... }
}
```

如果需要更有弹性一点，那么我们可以通过工厂或服务定位器实现：

```java
class Stopwatch { 
    final TimeSource timeSource; 
    Stopwatch () { 
        timeSource = DefaultTimeSource.getInstance(); 
    } 
    void start() { ... } 
    long stop() { ... } 
}
```

在使用这些传统方式进行依赖解析时，程序员必须做出适当权衡。构造器非常简洁，但却有一些限制（对象生存期，对象复用）。工厂确实解耦了客户与实现，但却需要样本式的代码。服务定位器更进一步地解耦了客户与实现，但却降低了编译时的类型安全。并且，这三个方式都不适合进行单元测试。例如，当程序员使用工厂时，该工厂的每一个产品都必须模拟出来，测试完后还要得记得清理：

```java
      void testStopwatch() { 
          TimeSource original = DefaultTimeSource.getInstance(); 
          DefaultTimeSource.setInstance(new MockTimeSource()); 
          try { 
              // Now, we can actually test Stopwatch. 
              Stopwatch sw = new Stopwatch(); 
              ... 
          } finally { 
              DefaultTimeSource.setInstance(original); 
          } 
      }
```

现实中，要模拟工厂将导致更多的样本式代码。测试模拟出的产品并清理它们在依赖多的情况下很快就控制不了了。更糟的是，程序员必须精确地预测未来到底需要多少这样的弹性，并为他做的“弹性选择”负责。如果程序员开始时选择了构造器方式，但后来需要一个更有弹性的方式，那他就不得不替换所有调用构造器的代码。如果程序员一开始过于谨慎地选择了工厂方式，结果可能导致要编写很多额外的样本式代码，引入了不必要的复杂度，潜在的问题比比皆是。

**依赖注入**就是为了解决这些问题。代替程序员调用构造器或工厂，一个称作**依赖注入器**的工具将把依赖传递给对象：

```java
      class Stopwatch { 
          final TimeSource timeSource; 
          @Inject Stopwatch(TimeSource timeSource) { 
              this.TimeSource = timeSource; 
          } 
          void start() { ... } 
          long stop() { ... } 
      }
```

注入器将更进一步地传递依赖给其他的依赖，直到它构造出整个对象图。例如，假设一个程序员需要注入器创建一StopwatchWidget 实例：

```java
 /** GUI for a Stopwatch */ 
 class StopwatchWidget { 
     @Inject StopwatchWidget(Stopwatch sw) { ... } 
     ... 
 }
```

注入器可能会：

1. 查找一个 TimeSource 实例
2. 使用找到的 TimeSource 实例构造一个 Stopwatch
3. 使用构造的 Stopwatch 实例构造一个 StopwatchWidget

这使得代码保持干净，使得程序员感到使用依赖（物）的基础设施非常容易。现在，在单元测试中，程序员可以直接构造对象（不使用注入器）并将该对象以模拟依赖的方式直接传入待测对象的构造中。程序员再也不需要为每一次测试都配置并清理工厂或服务定位器。这大大简化了我们的单元测试：

```java
      void testStopwatch() { 
          Stopwatch sw = new Stopwatch(new MockTimeSource()); 
          ... 
      }
```

完全降低了单元测试的复杂度，降低的复杂程度与待测对象的数目及其依赖成正比。**包 javax.inject 为使用这样的轻便类提供了依赖注入注解**，但没有引入依赖配置方式。依赖配置方式取决于注入器的实现。程序员只需要标注了构造器、方法或字段来说明它们的可注入性（上面的例子就是构造器注入）。依赖注入器通过这些注解来识别一个类的依赖，并在运行时注入这些依赖。此外，注入器要能够在**构建时**验证所有的依赖是否满足。相比之下，服务定位器在构建时是不能检测到依赖不满足情况的，直到运行时才能发现。

注入器实现有很多形式。一个注入器可以通过 XML、注解、DSL（领域规约语言），或是普通 Java 代码来进行配置。注入器实现可以使用反射或代码生成。使用编译时代码生成的注入器甚至可能没有它自己的运行时描述。而其他注入器实现无论在编译时还是运行时可能都不使用代码生成。一个“容器”，其实可以把它定义为一个注入器，不过包 javax.inject 不涉及非常大概念，旨在最小化注入器实现的限制。

## 2.@Inject

注解 @Inject 标识了可注入的构造器、方法或字段。可以用于静态或实例成员。一个可注入的成员可以被任何访问修饰符（private、package- private、protected、public）修饰。注入顺序为构造器，字段，最后是方法。超类的字段、方法将优先于子类的字段、方法被注入。对于同一个类的字段是不区分注入顺序的，同一个类的方法亦同。可注入的构造器指的是标注了 @Inject 并接受 0 个或多个依赖作为实参的构造器。对于每一个类而言，@Inject 最多只允许对一个类的一个构造器进行标注：

```java
@Inject ConstructorModifiers(opt) SimpleTypeName(FormalParameterList(opt)) Throwsopt ConstructorBody
```



